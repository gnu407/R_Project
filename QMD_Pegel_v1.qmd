---
title: "Elias_PegelUrsprung_2025"
format: html
editor: visual
---

25.03.2025 v1 by Jakob Kniess

# R Script to compare Partnach Gauge levels after and before at Partnach Ursprung

GitHub: follow this tutorial for everything else :)

<https://www.youtube.com/playlist?list=PLSviU861UtD81AuyYb3SbndmAA_qTCoLe>

```{r}
# LIBRARIES
library(dplyr)
#install.packages("dplyr")
```

## CONFIG

```{r}
# CONFIG
path_ursprung = normalizePath("C:\\Users\\Jakob\\OneDrive - Universität Augsburg\\Job Uni\\G-MONARCH\\ONGOING\\Elias_PegelOffset_2025\\Datensatz_Partnach_v1\\Partnach_Ursprung\\Abflüsse_nach_Jahren")

path_bock = normalizePath("C:\\Users\\Jakob\\OneDrive - Universität Augsburg\\Job Uni\\G-MONARCH\\ONGOING\\Elias_PegelOffset_2025\\Datensatz_Partnach_v1\\Partnach_Bockhütte\\Abflüsse_nach_Jahren")

```

## 1. Data Input

```{r}
# DATA INPUT
df_ursprung_RAW <- read_and_combine(path_ursprung)
df_bock_RAW <- read_and_combine(path_bock)
```

## 2. Functions

```{r}
# FUCTIONS

# F1 - Read and combine files
read_and_combine <- function(base_folder_path) {
  
  # List all CSV files that start with "Produkt_" in the year-based subfolders
  files <- list.files(base_folder_path, pattern = "^Produkt_.*\\.csv$", full.names = TRUE, recursive = TRUE)
  #print (files)
  if (length(files) == 0) {
    stop("No CSV files starting with 'Produkt_' found in the specified folder or its subfolders.")
  }
  
  # Read and standardize the columns before binding
  df_list <- lapply(files, function(file) {
    df <- read.csv(normalizePath(file))
    
    # Ensure that all columns exist and convert all to character for consistency
    df[] <- lapply(df, function(col) {
      # Convert each column to character
      col <- as.character(col)
      
      # Replace empty values with NaN (missing values should be converted to NaN)
      col[col == ""] <- NA
      
      return(col)
    })
    
    return(df)
  })
  
  # Combine all data frames
  combined_df <- bind_rows(df_list)
  
  return(combined_df)
}

#F2 - Function To clean the dataframes

clean_dataframe <- function(df) {
  # 0. Ch
  # 1. Set MESS_DATUM to Datetime format
  if ("MESS_DATUM" %in% colnames(df)) {
    df$MESS_DATUM <- trimws(df$MESS_DATUM)
    df$MESS_DATUM <- as.POSIXct(df$MESS_DATUM, format = "YYYY-mm-dd HH:MM:SS", tz = "UTC") # Adjust format if necessary
  }
  
  # 2. Remove STATIONS_ID Column
  if ("STATIONS_ID" %in% colnames(df)) {
    df <- df[, !colnames(df) %in% "STATIONS_ID"]
  }
  
  # 3. Convert NaN to NA
  df[df == "NaN"] <- NA
  
  # 4. Convert specific columns to numeric
  cols_to_convert <- c("Q", "P_R_W", "P_D_W", "T_W", "LF_W")
  
  # Apply conversion to numeric, if the columns exist
  for (col in cols_to_convert) {
    if (col %in% colnames(df)) {
      df[[col]] <- as.numeric(df[[col]])
    }
  }
  
  # 5. Round all numeric columns to 2 decimal places
  num_cols <- sapply(df, is.numeric)  # Identify numeric columns
  df[num_cols] <- round(df[num_cols], 2)  # Round numeric columns to 2 decimal places
  
  return(df)
}
```

## 3. Clean up Dataframes

```{r}
# Test
num_cols = sapply(df_ursprung_RAW, is.numeric)
print(num_cols)
```

```{r}
# Clean Dataframes
df_ursprung <- clean_dataframe(df_ursprung_RAW)
df_bock <- clean_dataframe(df_bock_RAW)


```

```{}
```

df_ursprung \<- read_and_combine(path_ursprung)
