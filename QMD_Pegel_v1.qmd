---
title: "Elias_PegelUrsprung_2025"
format: html
editor: visual
---

25.03.2025 v1 by Jakob Kniess

# R Script to compare Partnach Gauge levels after and before at Partnach Ursprung

GitHub: follow this tutorial for everything else :)

<https://www.youtube.com/playlist?list=PLSviU861UtD81AuyYb3SbndmAA_qTCoLe>

```{r}
# LIBRARIES
library(dplyr)
library(lubridate)
library(ggplot2)
library(plotly)
#install.packages("dplyr")
```

## CONFIG

```{r}
# CONFIG
path_ursprung = normalizePath("C:\\Users\\Jakob\\OneDrive - Universität Augsburg\\Job Uni\\G-MONARCH\\ONGOING\\Elias_PegelOffset_2025\\Datensatz_Partnach_v1\\Partnach_Ursprung\\Abflüsse_nach_Jahren")

path_bock = normalizePath("C:\\Users\\Jakob\\OneDrive - Universität Augsburg\\Job Uni\\G-MONARCH\\ONGOING\\Elias_PegelOffset_2025\\Datensatz_Partnach_v1\\Partnach_Bockhütte\\Abflüsse_nach_Jahren")

```

## 1. Functions

```{r}
# FUCTIONS

# F1 - Read and combine files
read_and_combine <- function(base_folder_path) {
  
  # List all CSV files that start with "Produkt_" in the year-based subfolders
  files <- list.files(base_folder_path, pattern = "^Produkt_.*\\.csv$", full.names = TRUE, recursive = TRUE)
  #print (files)
  if (length(files) == 0) {
    stop("No CSV files starting with 'Produkt_' found in the specified folder or its subfolders.")
  }
  
  # Read and standardize the columns before binding
  df_list <- lapply(files, function(file) {
    df <- read.csv(normalizePath(file))
    
    # Ensure that all columns exist and convert all to character for consistency
    df[] <- lapply(df, function(col) {
      # Convert each column to character
      col <- as.character(col)
      
      # Replace empty values with NaN (missing values should be converted to NaN)
      col[col == ""] <- NA
      
      return(col)
    })
    
    return(df)
  })
  
  # Combine all data frames
  combined_df <- bind_rows(df_list)
  
  return(combined_df)
}

#F2 - Function To clean the dataframes

clean_dataframe <- function(df) {
  
  # 0. Convert NaN to NA
  df[df == "NaN"] <- NA
  
  # 1. Set MESS_DATUM to Datetime format
  if ("MESS_DATUM" %in% colnames(df)) {
    df$MESS_DATUM <- strptime(df$MESS_DATUM, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  }
  
  # 2. Remove STATIONS_ID Column
  if ("STATIONS_ID" %in% colnames(df)) {
    df <- df[, !colnames(df) %in% "STATIONS_ID"]
  }
  

  
  # 3. Convert specific columns to numeric
  cols_to_convert <- c("Q", "P_R_W", "P_D_W", "T_W", "LF_W")
  
  # Apply conversion to numeric, if the columns exist
  for (col in cols_to_convert) {
    if (col %in% colnames(df)) {
      df[[col]] <- as.numeric(df[[col]])
    }
  }
  
  # 4. Round all numeric columns to 2 decimal places
  num_cols <- sapply(df, is.numeric)  # Identify numeric columns
  df[num_cols] <- round(df[num_cols], 2)  # Round numeric columns to 2 decimal places
  
  return(df)
}
```


## 2. Data Input

```{r}
# DATA INPUT
df_ursprung_RAW <- read_and_combine(path_ursprung)
df_bock_RAW <- read_and_combine(path_bock)
```

## 3. Clean up Dataframes

```{r}
# Clean Dataframes
df_ursprung <- clean_dataframe(df_ursprung_RAW)
df_bock <- clean_dataframe(df_bock_RAW)

```
## Prepare for Plotting
```{r}
# Remove all Years before 2015

# Filter rows where MESS_DATUM is before 2015 using base R
df_ursprung_00 <- df_ursprung[as.numeric(format(df_ursprung$MESS_DATUM, "%Y")) >= 2015, ]
df_bock_00 <- df_bock[as.numeric(format(df_bock$MESS_DATUM, "%Y")) >= 2015, ]
#head(df_bock_00)
```

```{r}
# Create Dataframes with daily data

# Extract the date (ignoring time) and group by that
df_ursprung_01 <- df_ursprung_00 %>%
  mutate(Date = as.Date(MESS_DATUM)) %>%  # Create a new Date column with only the date part
  group_by(Date) %>%  # Group by the Date
  summarize(across(everything(), mean, na.rm = TRUE))  # Calculate mean for all columns, ignoring NA


# Extract the date (ignoring time) and group by that
df_bock_01 <- df_bock_00 %>%
  mutate(Date = as.Date(MESS_DATUM)) %>%  # Create a new Date column with only the date part
  group_by(Date) %>%  # Group by the Date
  summarize(across(everything(), mean, na.rm = TRUE))  # Calculate mean for all columns, ignoring NA

```

```{r}
# Create a single Dataframe

# Merge the dataframes based on MESS_DATUM, keeping only one MESS_DATUM column
df_combined_01<- df_ursprung_01 %>%
  left_join(df_bock_01, by = "Date", suffix = c("_Ursprung", "_Bock"))

# CLEANUP - it got a bit dirty 
# Remove unwanted columns and rename Date_Ursprung to MESS_DATUM
df_combined_00 <- df_combined_01 %>%
  select(-MESS_DATUM_Ursprung,   # Remove the redundant MESS_DATUM from df_bock_01
         -MESS_DATUM_Bock) %>%      # Remove Date_Bock column
  rename(MESS_DATUM = Date)  # Rename Date_Ursprung to MESS_DATUM

# Round to 3 decimal places
df_combined_00[num_cols] <- round(df_combined_00[num_cols], 3)  # Round numeric columns to 2 decimal places
  

```

## Plotting

LEGACY
// Extract Year from MESS_DATUM column and add as a new column
df_combined_00 <- df_combined_00 %>%
  mutate(Year = as.numeric(format(MESS_DATUM, "%Y")))  # Extract year as numeric

//Create the scatterplot with publication-quality formatting
p <- ggplot(df_combined_00, aes(x = Q_Bock, y = Q_Ursprung, color = factor(Year))) +
  geom_point(alpha = 0.7, size = 2) +  # Scatterplot with semi-transparent points
  scale_colour_brewer(palette = "Paired") +  # Use a color scale (Viridis is colorblind-friendly)
  labs(x = "Q Bock", y = "Q Ursprung", color = "Year") +  # Axis labels and legend title
  theme_minimal(base_size = 14) +  # Minimal theme with a bigger base font size
  theme(
    legend.position = "right",  # Position the legend to the right
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    axis.text = element_text(size = 12),
    #panel.grid.major = element_blank(),  # Remove major gridlines
    #panel.grid.minor = element_blank(),  # Remove minor gridlines
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)  # Title
  ) +
  ggtitle("Scatter Plot of Q_Bock vs. Q_Ursprung")  # Add a title

// Print the plot
print(p)




```{r}
# PLOT - DISCHARGE
# Extract Year from MESS_DATUM column and add as a new column
df_combined_00 <- df_combined_00 %>%
  mutate(Year = as.numeric(format(MESS_DATUM, "%Y")))  # Extract year as numeric

# Create the scatterplot with publication-quality formatting
p <- ggplot(df_combined_00, aes(x = Q_Bock, y = Q_Ursprung, color = factor(Year), text = paste("Year: ", Year, "<br>Q Bockhütte: ", Q_Bock, " m³", 
                                            "<br>Q Partnach-Ursprung: ", Q_Ursprung, " m³"))) +
  geom_point(alpha = 0.7, size = 2) +  # Scatterplot with semi-transparent points
  scale_colour_brewer(palette = "Paired") +  # Use a color scale
  labs(x = "Q Bockhütte [m³]", y = "Q Partnach-Ursprung [m³]", color = "Year") +  # Axis labels and legend title
  theme_minimal(base_size = 14) +  # Minimal theme with a bigger base font size
  theme(
    legend.position = "right",  # Position the legend to the right
    legend.title = element_text(size = 14, face = "normal"),
    legend.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "normal"),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5)  # Title
  ) +
  ggtitle("Plot of average daily discharge at Bockhütte and Partnach-Ursprung")

# Convert the ggplot object to a plotly object for interactivity
interactive_plot <- ggplotly(p, tooltip = "text")  # Tooltip shows the year when hovering over the points

# Display the interactive plot
interactive_plot
```

```{r}

# PLOT - WATERLEVEL
# Extract Year from MESS_DATUM column and add as a new column
df_combined_00 <- df_combined_00 %>%
  mutate(Year = as.numeric(format(MESS_DATUM, "%Y")))  # Extract year as numeric

# Create the scatterplot with publication-quality formatting
p <- ggplot(df_combined_00, aes(x = P_D_W_Bock, y = P_D_W_Ursprung, color = factor(Year), text = paste("Year: ", Year, "<br>Q Bockhütte: ", Q_Bock, " m³", 
                                            "<br>Q Partnach-Ursprung: ", Q_Ursprung, " m³"))) +
  geom_point(alpha = 0.7, size = 2) +  # Scatterplot with semi-transparent points
  scale_colour_brewer(palette = "Dark2") +  # Use a color scale
  labs(x = "Waterlevel Bockhütte [cm]", y = "Waterlevel Partnach-Ursprung [cm]", color = "Year") +  # Axis labels and legend title
  theme_minimal(base_size = 14) +  # Minimal theme with a bigger base font size
  theme(
    legend.position = "right",  # Position the legend to the right
    legend.title = element_text(size = 14, face = "normal"),
    legend.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "normal"),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5)  # Title
  ) +
  ggtitle("Plot of average daily waterlevel at Bockhütte and Partnach-Ursprung")

# Convert the ggplot object to a plotly object for interactivity
interactive_plot <- ggplotly(p, tooltip = "text")  # Tooltip shows the year when hovering over the points

# Display the interactive plot
interactive_plot

```
```{r}

# Create the scatterplot with publication-quality formatting
p <- ggplot(df_combined_00, aes(x = P_D_W_Bock, y = P_D_W_Ursprung, color = factor(Year), 
                               text = paste("Year: ", Year, "<br>Waterlevel Bockhütte: ", P_D_W_Bock, " cm", 
                                            "<br>Waterlevel Partnach-Ursprung: ", P_D_W_Ursprung, " cm"))) +
  geom_point(alpha = 0.7, size = 2) +  # Scatterplot with semi-transparent points
  scale_colour_brewer(palette = "Dark2") +  # Use a color scale
  labs(x = "Waterlevel Bockhütte [cm]", y = "Waterlevel Partnach-Ursprung [cm]", color = "Year") +  # Axis labels and legend title
  theme_minimal(base_size = 14) +  # Minimal theme with a bigger base font size
  theme(
    legend.position = "right",  # Position the legend to the right
    legend.title = element_text(size = 14, face = "normal"),
    legend.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "normal"),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5)  # Title
  ) +
  ggtitle("Plot of average daily waterlevel at Bockhütte and Partnach-Ursprung")

# Convert the ggplot object to a plotly object for interactivity
interactive_plot <- ggplotly(p, tooltip = "text")  # Tooltip shows the custom information when hovering over the points

# Display the interactive plot
interactive_plot
```

```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)

# Extract Year from MESS_DATUM column and add as a new column
df_combined_00 <- df_combined_00 %>%
  mutate(Year = as.numeric(format(MESS_DATUM, "%Y")))  # Extract year as numeric

# Create the scatterplot with refined customization
p <- ggplot(df_combined_00, aes(x = Q_Bock, y = Q_Ursprung, color = factor(Year))) +
  geom_point(alpha = 0.7, size = 2) +  # Scatterplot with smaller points and semi-transparency
  scale_color_manual(values = RColorBrewer::brewer.pal(n = length(unique(df_combined_00$Year)), name = "Set3")) +  # Discrete color scale
  labs(x = "Q Bock", y = "Q Ursprung", color = "Year") +  # Axis labels and legend title
  theme_minimal(base_size = 14) +  # Minimal theme with a bigger base font size
  theme(
    legend.position = "right",  # Position the legend to the right
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid.major = element_line(color = "gray", size = 0.5),  # Add gridlines with a light gray color
    panel.grid.minor = element_line(color = "gray", size = 0.2, linetype = "dotted"),  # Minor gridlines with a dotted line
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # Title formatting
    panel.border = element_blank()  # Remove the panel border
  ) +
  scale_x_continuous(breaks = seq(min(df_combined_00$Q_Bock, na.rm = TRUE), 
                                 max(df_combined_00$Q_Bock, na.rm = TRUE), 
                                 by = (max(df_combined_00$Q_Bock, na.rm = TRUE) - min(df_combined_00$Q_Bock, na.rm = TRUE)) / 5)) +  # Customize x-axis breaks
  scale_y_continuous(breaks = seq(min(df_combined_00$Q_Ursprung, na.rm = TRUE), 
                                 max(df_combined_00$Q_Ursprung, na.rm = TRUE), 
                                 by = (max(df_combined_00$Q_Ursprung, na.rm = TRUE) - min(df_combined_00$Q_Ursprung, na.rm = TRUE)) / 5)) +  # Customize y-axis breaks
  ggtitle("Scatter Plot of Q_Bock vs. Q_Ursprung")  # Add a title

# Print the plot
print(p)

```

